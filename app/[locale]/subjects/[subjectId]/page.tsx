import { auth } from '@clerk/nextjs/server';
import type { Metadata } from 'next';
import { redirect } from 'next/navigation';
import Link from 'next/link';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card';
import { Button } from '@/components/ui/Button';
import { BreadcrumbsJsonLd } from '@/components/seo/BreadcrumbsJsonLd';
import { getDatabase } from '@/lib/mongodb';
import { getLatestKeywords } from '@/lib/seo';
import { SubjectPractice } from '@/components/subjects/SubjectPractice';
import { ObjectId } from 'mongodb';
import { SubjectHeader } from '@/components/subjects/SubjectHeader';
import { Tabs } from '@/components/ui/Tabs';
import { Resources } from '@/components/subjects/Resources';
import { Analytics as SubjectAnalytics } from '@/components/subjects/Analytics';
import { openai } from '@/lib/openai';

interface SubjectPageProps {
  params: Promise<{ subjectId: string }>;
}

export const dynamic = 'force-dynamic';

export default async function SubjectDetailPage({ params }: SubjectPageProps) {
  const { userId } = await auth();
  if (!userId) redirect('/sign-in');

  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
  // Get subject details and topics
  const { subjectId: slugParam } = await params;
  if (!slugParam) {
    return (
      <div className="max-w-3xl mx-auto px-4 py-10">
        <h1 className="text-2xl font-bold mb-2">Subject not found</h1>
        <Link href="/subjects" className="text-blue-600 hover:underline">‚Üê Back to Subjects</Link>
      </div>
    );
  }

  const subjects = await fetch(`${baseUrl}/api/subjects`, { cache: 'no-store' }).then(r => r.ok ? r.json() : []);
  let subject = (subjects || []).find((s: any) => (s.slug === slugParam) || (String(s._id) === slugParam));

  // Fallback: auto-create virtual subject if not found (AI-first flow)
  if (!subject) {
    const nameFromSlug = slugParam.replace(/-/g, ' ').replace(/\b\w/g, (m) => m.toUpperCase());
    const db = await getDatabase();
    const slug = slugParam;
    const levels = [
      { id: 'basic', name: 'Basic' },
      { id: 'intermediate', name: 'Intermediate' },
      { id: 'advanced', name: 'Advanced' },
    ];
    const newDoc = { name: nameFromSlug, slug, description: `${nameFromSlug} autogenerated subject`, icon: 'üìö', color: 'blue', category: 'academic', levels, isActive: true, createdAt: new Date(), updatedAt: new Date() };
    try {
      await db.collection('subjects').updateOne({ slug }, { $setOnInsert: newDoc }, { upsert: true });
      // Read back with _id guaranteed
      subject = await db.collection('subjects').findOne({ slug });
    } catch { }
    if (!subject) subject = newDoc as any;
  }

  // Fetch syllabus (topics) grouped by level
  let topics: any[] = [];
  try {
    const findId = subject._id ? String(subject._id) : subject.slug;
    const topicsRes = await fetch(`${baseUrl}/api/syllabus?subjectId=${findId}`, { cache: 'no-store' });
    topics = topicsRes.ok ? await topicsRes.json() : [];
  } catch { }

  // If no topics exist yet, try to generate a sensible syllabus (AI if available; fallback to defaults), then persist
  if (!topics.length) {
    const db = await getDatabase();
    const topicsCol = db.collection('topics');
    let generated: Record<string, string[]> | null = null;
    if (openai) {
      try {
        const prompt = `Create a short syllabus for the subject "${subject.name}" with 3 levels: Basic, Intermediate, Advanced. For each level, list 5 concise chapter titles. Return JSON like {"Basic":["..."],"Intermediate":["..."],"Advanced":["..."]}`;
        const resp = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [{ role: 'user', content: prompt }],
          response_format: { type: 'json_object' },
          temperature: 0.5,
        });
        const content = resp.choices[0]?.message?.content || '{}';
        generated = JSON.parse(content);
      } catch {
        generated = null;
      }
    }
    if (!generated) {
      generated = {
        Basic: ['Introduction', 'Core Concepts', 'Key Terms', 'Fundamentals Practice', 'Quick Review'],
        Intermediate: ['Applied Concepts', 'Problem Solving', 'Case Studies', 'Mixed Practice', 'Checkpoint'],
        Advanced: ['Advanced Topics', 'Edge Cases', 'Projects', 'Mock Test', 'Final Review'],
      } as any;
    }
    const toInsert: any[] = [];
    const levelMap: Record<string, string> = { Basic: 'basic', Intermediate: 'intermediate', Advanced: 'advanced' };
    const generatedTopics = generated as Record<string, string[]>;
    Object.entries(generatedTopics).forEach(([lvlName, arr]) => {
      const levelId = levelMap[lvlName] || lvlName.toLowerCase();
      (arr as string[]).forEach((title, idx) => {
        toInsert.push({ subjectId: subject._id ? String(subject._id) : subject.slug, levelId, name: title, slug: title.toLowerCase().replace(/[^a-z0-9]+/g, '-'), order: idx + 1, createdAt: new Date(), updatedAt: new Date() });
      });
    });
    if (toInsert.length) {
      try { await topicsCol.insertMany(toInsert); } catch { }
      topics = toInsert;
    }
  }
  const topicsByLevel: Record<string, any[]> = {};
  // Ensure plain objects (string ids) for client components
  topics = topics.map((t: any) => ({
    ...t,
    _id: t._id ? String(t._id) : undefined,
    subjectId: t.subjectId ? String(t.subjectId) : undefined,
  }));
  topics.forEach((t: any) => {
    const key = t.levelId || 'unknown';
    if (!topicsByLevel[key]) topicsByLevel[key] = [];
    topicsByLevel[key].push(t);
  });

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white border-b">
        <div className="container mx-auto px-4 py-4 flex justify-between items-center">
          <div>
            <Link href="/subjects" className="text-blue-600 hover:underline text-sm mb-1 block">
              ‚Üê Back to Subjects
            </Link>
            <h1 className="text-2xl font-bold text-blue-600">{subject.name}</h1>
          </div>
        </div>
      </header>

      <main className="container mx-auto px-4 py-8">
        <BreadcrumbsJsonLd items={[
          { name: 'Home', url: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}` },
          { name: 'Subjects', url: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/subjects` },
          { name: subject.name, url: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/subjects/${slugParam}` },
        ]} />
        <SubjectHeader name={subject.name} description={subject.description} chaptersCount={topics.length} />
        <Tabs
          tabs={[
            {
              id: 'overview', label: 'Overview', content: (
                <div className="grid md:grid-cols-2 gap-6">
                  <div className="p-4 border rounded-xl bg-white">
                    <h3 className="font-semibold mb-2">Syllabus Summary</h3>
                    <p className="text-sm text-gray-600">Explore levels and chapters from the sidebar. Your mastery updates as you practice.</p>
                  </div>
                  <div className="p-4 border rounded-xl bg-white">
                    <h3 className="font-semibold mb-2">Recommendations</h3>
                    <p className="text-sm text-gray-600">Use Daily Set or Weak Areas in the Practice tab for targeted improvement.</p>
                  </div>
                </div>
              )
            },
            {
              id: 'practice', label: 'Practice', content: (
                <div className="grid lg:grid-cols-3 gap-6">
                  <div className="lg:col-span-3">
                    <SubjectPractice subjectName={subject.name} levels={subject.levels || []} topicsByLevel={topicsByLevel} />
                  </div>
                </div>
              )
            },
            {
              id: 'resources', label: 'Resources', content: (
                <Resources subjectName={subject.name} />
              )
            },
            {
              id: 'analytics', label: 'Analytics', content: (
                <SubjectAnalytics subjectName={subject.name} />
              )
            },
          ]}
        />
      </main>
    </div>
  );
}

export async function generateMetadata({ params }: { params: Promise<{ subjectId: string }> }): Promise<Metadata> {
  const { subjectId } = await params;
  let name = 'Subject';
  try {
    const db = await getDatabase();
    const orConditions: any[] = [{ slug: subjectId }];
    if (ObjectId.isValid(subjectId)) {
      orConditions.push({ _id: new ObjectId(subjectId) });
    }
    const subject = await db.collection('subjects').findOne({ $or: orConditions });
    name = subject?.name || 'Subject';
  } catch (error) {
    console.error('Error in generateMetadata:', error);
  }
  const kws = await getLatestKeywords().catch(() => []);
  return {
    title: `${name} | Refectl`,
    description: `Learn ${name} with AI-adaptive quizzes. Choose level and chapters to master topics.`,
    keywords: kws.length ? kws : undefined,
  };
}


